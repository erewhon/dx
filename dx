#!/bin/bash

# dx - Developer shell wrapper for Docker/Container
# Supports both Docker and Apple's container command

set -e

IMAGE_NAME="dx:latest"
WORKSPACE="/workspace"

# Detect which container runtime is available
detect_runtime() {
  if command -v container &>/dev/null; then
    echo "container"
  elif command -v docker &>/dev/null; then
    echo "docker"
  else
    echo "error: neither 'container' nor 'docker' command found" >&2
    echo "Please install Docker Desktop or Apple's container tools" >&2
    exit 1
  fi
}

# Check if the image exists
check_image() {
  local runtime=$1

  if [ "$runtime" = "container" ]; then
    container image ls | grep -q "dx.*latest" 2>/dev/null
  else
    docker image ls | grep -q "^dx" 2>/dev/null
  fi
}

# Build the image if it doesn't exist
ensure_image() {
  local runtime=$1

  if ! check_image "$runtime"; then
    echo "Image '${IMAGE_NAME}' not found. Building..."
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

    if [ "$runtime" = "container" ]; then
      container build -t "${IMAGE_NAME}" "$SCRIPT_DIR"
    else
      docker build -t "${IMAGE_NAME}" "$SCRIPT_DIR"
    fi
  fi
}

# Run the container
run_container() {
  local runtime=$1
  shift

  # Get current directory
  local current_dir="$(pwd)"

  # Generate container name based on project and branch
  local project_name=$(basename "$current_dir")
  local branch_name=""

  # Try to get branch name (jj first, then git)
  if command -v jj &>/dev/null && [ -d .jj ]; then
    branch_name=$(jj log -r @ --no-graph -T 'bookmarks' 2>/dev/null | head -n1 | tr -d ' ')
  elif command -v git &>/dev/null && [ -d .git ]; then
    branch_name=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
  fi

  # Sanitize names for container naming (only alphanumeric, underscore, period, hyphen)
  project_name=$(echo "$project_name" | sed 's/[^a-zA-Z0-9._-]/-/g')
  branch_name=$(echo "$branch_name" | sed 's/[^a-zA-Z0-9._-]/-/g')

  # Build container name
  local container_name="dx-${project_name}"
  if [ -n "$branch_name" ]; then
    container_name="${container_name}-${branch_name}"
  fi

  # Build run command based on runtime
  local run_cmd=""

  if [ "$runtime" = "container" ]; then
    run_cmd="container run"
  else
    run_cmd="docker run"
  fi

  # Common options
  local common_opts=(
    "--rm"
    "-it"
    "--name" "${container_name}"
    "-v" "${current_dir}:${WORKSPACE}"
    "-w" "${WORKSPACE}"
  )

  # Resource allocation (4 CPUs, 4GB memory)
  if [ "$runtime" = "container" ]; then
    # Apple container syntax
    common_opts+=("--cpus=4" "--memory=4G")
  else
    # Docker syntax
    common_opts+=("--cpus=4" "--memory=4g")
  fi

  # Startup script for copying files (used for Apple container workaround)
  local startup_script=""

  # Handle file mounts - Apple container doesn't support file mounts, so we use .dx directory
  if [ "$runtime" = "container" ]; then
    # Create .dx directory for staging files
    mkdir -p "$HOME/.dx"
    common_opts+=("-v" "$HOME/.dx:/home/dx/.dx:ro")

    # Copy gitconfig
    if [ -f "$HOME/.gitconfig" ]; then
      cp "$HOME/.gitconfig" "$HOME/.dx/gitconfig"
      startup_script+="cp ~/.dx/gitconfig ~/.gitconfig 2>/dev/null || true; "
    fi

    # Copy claude.json
    if [ -f "$HOME/.claude.json" ]; then
      cp "$HOME/.claude.json" "$HOME/.dx/claude.json"
      startup_script+="cp ~/.dx/claude.json ~/.claude.json 2>/dev/null || true; "
    fi

    # Copy localtime for timezone
    if [ -z "$TZ" ] && [ -f /etc/localtime ]; then
      cp /etc/localtime "$HOME/.dx/localtime"
      startup_script+="sudo cp ~/.dx/localtime /etc/localtime 2>/dev/null || cp ~/.dx/localtime /etc/localtime 2>/dev/null || true; "
    fi
  else
    # Docker: direct file mounts work fine
    if [ -f "$HOME/.gitconfig" ]; then
      common_opts+=("-v" "$HOME/.gitconfig:/home/dx/.gitconfig:ro")
    fi

    if [ -f "$HOME/.claude.json" ]; then
      common_opts+=("-v" "$HOME/.claude.json:/home/dx/.claude.json")
    fi

    # Pass through timezone
    if [ -z "$TZ" ] && [ -f /etc/localtime ]; then
      common_opts+=("-v" "/etc/localtime:/etc/localtime:ro")
    fi
  fi

  # Mount .ssh directory (works for both)
  if [ -d "$HOME/.ssh" ]; then
    common_opts+=("-v" "$HOME/.ssh:/home/dx/.ssh:ro")
  fi

  # Create and mount .claude directory for persistent Claude Code settings
  mkdir -p "$HOME/.claude"
  common_opts+=("-v" "$HOME/.claude:/home/dx/.claude")

  # Create and mount .cache directory for persistent caching
  if [ -d "$HOME/.cache" ]; then
    common_opts+=("-v" "$HOME/.cache:/home/dx/.cache")
  fi

  # Mount .config directory read-only
  if [ -d "$HOME/.config" ]; then
    common_opts+=("-v" "$HOME/.config:/home/dx/.config:ro")
  fi

  # Pass through TZ environment variable if set
  if [ -n "$TZ" ]; then
    common_opts+=("-e" "TZ=$TZ")
  fi

  # Pass through ANTHROPIC_API_KEY if set
  if [ -n "$ANTHROPIC_API_KEY" ]; then
    common_opts+=("-e" "ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY")
  fi

  # If arguments provided, run as command; otherwise start zsh
  if [ $# -eq 0 ]; then
    $run_cmd "${common_opts[@]}" "${IMAGE_NAME}" /bin/zsh -c "${startup_script}exec zsh"
  else
    $run_cmd "${common_opts[@]}" "${IMAGE_NAME}" /bin/zsh -c "${startup_script}$*"
  fi
}

# Main execution
main() {
  local runtime=$(detect_runtime)
  ensure_image "$runtime"
  run_container "$runtime" "$@"
}

main "$@"
